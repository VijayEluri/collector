#
# Copyright 2011 Ning, Inc.
#
# Ning licenses this file to you under the Apache License, version 2.0
# (the "License"); you may not use this file except in compliance with the
# License.  You may obtain a copy of the License at:
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.
#

#
# Send NetFlow data.
#
# /!\ nfdump is assumed to be in the path /!\
#
# Periodically, every 5 minutes by default, nfcapd will rename the current
# file (nfcad.current.<pid>) to nfcapd.%i%02i%02i%02i%02i (year/month/day/hour/minute).
# We look for these files, and send them to Scribe or collector.
#
# A ramfs is strongly encouraged for the data output directory (-l option):
#
#  mkfs -q /dev/ram1 8589934592  # 8 GB
#  mkdir -p /mnt/nfdump
#  mount /dev/ram1 /mnt/nfdump
#


import argparse
import base64
import glob
import logging
import os
import socket
import subprocess
import sys
import time
import threading

from scribe import scribe
import thrift
from thrift.transport import TTransport, TSocket
from thrift.protocol import TBinaryProtocol

from netflow.ttypes import Netflow


log = logging.getLogger('nfcapd2coll')

class NetflowDumpSender(threading.Thread):

    def __init__(self, threadNb, infile, scribeHost, scribePort):
        threading.Thread.__init__(self)
        self.infile = infile
        self.scribeHost = scribeHost
        self.scribePort = scribePort
        self.events = []

    def run(self):
        # Output data as CSV into csvOutput
        nfdump = subprocess.Popen(['nfdump', '-q', '-r', self.infile, '-o', 'csv'], stdout=subprocess.PIPE)
        csvOutput = nfdump.communicate()[0]

        self.__parse_data(csvOutput)
        try:
            os.remove(self.infile)
            log.debug('Deleted file: %s', self.infile)
        except os.error, err:
            log.error('Unable to delete file [%s]: %s', self.infile, err)
        log.info('Done with file %s - start sending it', self.infile)
        self.__send_events()

    def __parse_data(self, data):
        """Given CSV generated by nfdump, create the associated events

        Keyword arguments:
        data -- CSV output of nfdump

        """
        for line in data.split('\n'):
            payload = line.split(',')
            if len(payload) > 1:
                self.events.append(self.__create_event(payload))
        log.info('Created %d events from file %s', len(self.events), self.infile)

    def __create_event(self, netflowPayload):
        """Create Netflow event from a dump line

        Keyword arguments:
        netflowPayload -- tuple containing all Netflow fields

        """
        transportOut = TTransport.TMemoryBuffer()
        protocolOut = TBinaryProtocol.TBinaryProtocol(transportOut)

        # The first field looks like: 2004-07-11 10:31:40
        try:
            msgDate = time.mktime(time.strptime(netflowPayload[0], "%Y-%m-%d %H:%M:%S"))
        except ValueError, err:
            log.info('Ignoring bad line from file %s: %s', self.infile, netflowPayload)
            return None
        except AttributeError, err:
            log.info('Ignoring bad line from file %s: %s', self.infile, netflowPayload)
            return None

        timeInMilliSinceEpoch = msgDate * 1000

        netflow = Netflow(timeInMilliSinceEpoch,
                          netflowPayload[0],
                          netflowPayload[1],
                          netflowPayload[2],
                          netflowPayload[3],
                          netflowPayload[4],
                          netflowPayload[5],
                          netflowPayload[6],
                          netflowPayload[7],
                          netflowPayload[8],
                          netflowPayload[9],
                          netflowPayload[10],
                          netflowPayload[11],
                          netflowPayload[12],
                          netflowPayload[13],
                          netflowPayload[14],
                          netflowPayload[15],
                          netflowPayload[16],
                          netflowPayload[17],
                          netflowPayload[18],
                          netflowPayload[19],
                          netflowPayload[20],
                          netflowPayload[21],
                          netflowPayload[22],
                          netflowPayload[23],
                          netflowPayload[24],
                          netflowPayload[25],
                          netflowPayload[26],
                          netflowPayload[27],
                          netflowPayload[28],
                          netflowPayload[29],
                          netflowPayload[30],
                          netflowPayload[31],
                          netflowPayload[32],
                          netflowPayload[33],
                          netflowPayload[34],
                          netflowPayload[35],
                          netflowPayload[36],
                          netflowPayload[37],
                          netflowPayload[38],
                          netflowPayload[39],
                          netflowPayload[40],
                          netflowPayload[41])
        netflow.write(protocolOut)
        netflowInBytes = transportOut.getvalue()
        log.debug('Created: %s', str(netflow))

        return scribe.LogEntry("Netflow", str(timeInMilliSinceEpoch) + ":" + base64.b64encode(netflowInBytes))

    def __send_events(self):
        """Send all events
        """
        socket = TSocket.TSocket(host=self.scribeHost, port=self.scribePort)
        transport = TTransport.TFramedTransport(socket)
        protocol = TBinaryProtocol.TBinaryProtocol(trans=transport, strictRead=False, strictWrite=False)
        client = scribe.Client(iprot=protocol, oprot=protocol)

        transport.open()
        log.info('Sending %d messages from file %s to %s:%d', len(self.events), self.infile, self.scribeHost, self.scribePort)
        result = client.Log(messages=self.events)
        transport.close()

        return result

def generate_netflow_events_from_dumps(directory, scribeHost, scribePort):
    """Given a directory of nfcapd files, create events for all rotated files
    (not current one).
    Parsed files are deleted.

    Keyword arguments:
    directory -- directory containing dumps
    scribeHost -- Scribe server to talk to
    scribePort -- Scribe server's port

    """
    threads = []
    # The files look like nfcapd.201011021335
    # We don't use nfdump -R to delete processed files as we go.
    # Given a day of data, send by batches (limit memory)
    for i in range(10):
        for j in range(10):
            #                                              nfcapd.201105050800
            for file in glob.glob(os.path.join(directory, 'nfcapd.????????'+str(i)+str(j)+'??')):
                log.info('Processing file: %s', file)
                sender = NetflowDumpSender(1 + len(threads), file, scribeHost, scribePort)
                threads.append(sender)
                sender.start()

            log.info('Parsed %s, created %d threads', directory, len(threads))

            for thread in threads:
                thread.join()

def main(argv=None):
    handler = logging.StreamHandler(sys.stdout)
    log.setLevel(logging.INFO)
    log.addHandler(handler)
    log.debug('Logging handler configured')

    if argv is None:
        argv = sys.argv

    parser = argparse.ArgumentParser(description='Extract Netflow events from nfcapd dumps and forward them remotely to Scribe.')
    parser.add_argument('--directory', required=True, help='Directory of files to parse')
    parser.add_argument('--scribeHost', required=True, help='Scribe server to connect to')
    parser.add_argument('--scribePort', required=True, help='Scribe port')
    args = parser.parse_args()

    try:
        directory, scribeHost, scribePort = args.directory, args.scribeHost, int(args.scribePort)
        log.info('Looking for files in %s, sending events to %s:%d', directory, scribeHost, scribePort)
        generate_netflow_events_from_dumps(directory, scribeHost, scribePort)
    except thrift.transport.TTransport.TTransportException, err:
        log.error('Unable to connect to Scribe: %s', err)

if __name__ == "__main__":
    sys.exit(main())
